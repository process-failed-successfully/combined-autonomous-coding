# Combined Autonomous Coding Agent - Project Specification

## Overview
This repository contains a framework for running autonomous coding agents (Gemini and Cursor) that can interact with local codebases to perform development tasks, management duties, and Jira integration. This specification serves as the primary blueprint for the agent's behavior and project evolution.

## Project Goals & Best Practices

### 1. Abstract Agent Logic
- **Objective**: Move core agent execution logic and subprocess coordination into a shared base layer (`BaseAgent` and `BaseClient`).
- **Best Practice**: Follow the DRY (Don't Repeat Yourself) principle and use inheritance to share common state management and execution flows.

### 2. Standardize Prompt Management
- **Objective**: Consolidate prompt generation logic into `agents/shared/prompts.py`.
- **Best Practice**: Use template-based prompt construction to ensure consistency and prevent "prompt drift" between different agent models.

### 3. Improve Reliability & Observability
- **Objective**: Unify telemetry and notification logic within the base classes.
- **Best Practice**: Implement structured logging and real-time metrics (Prometheus/Grafana) to provide full visibility into agent performance and failures.

### 4. Support for Extensibility
- **Objective**: Design the architecture to allow "pluggable" agent types.
- **Best Practice**: Use abstract base classes (ABCs) to define strict interfaces for new agent implementations, ensuring future models (e.g., Claude, OpenAI) can be added with minimal friction.

### 5. Enforce Strict Typing and Linting
- **Objective**: Achieve 100% type coverage with `mypy` and adhere to PEP 8 via `flake8`.
- **Best Practice**: Use static analysis tools to catch bugs early and maintain a high-quality, readable codebase.

### 6. Automated Verification Pipeline
- **Objective**: Integrate `run_tests.sh` and custom verification logic into a robust CI/CD process.
- **Best Practice**: Require automated "sanity checks" and unit test passes before any agent-suggested code is considered "complete."

### 7. Secure Credential & Secret Management
- **Objective**: Strictly manage Jira tokens, API keys, and other secrets using environment variables.
- **Best Practice**: Zero-tolerance for hardcoded secrets. Use `.env.template` for local development and secure secrets management in production/CI.

### 8. Resilient Error Recovery & State Persistence
- **Objective**: Implement mechanisms to save and restore agent state across sessions.
- **Best Practice**: Ensure the agent can resume from the last successful iteration after a timeout or crash, minimizing wasted tokens and time.

### 9. Optimize Containerized Environments
- **Objective**: Refactor the `Dockerfile` for multi-stage builds and non-root execution.
- **Best Practice**: Minimize the attack surface and image size while ensuring a consistent, "reproducible" environment for the agent to operate in.

### 10. Advanced Jira Workflow Integration
- **Objective**: Automate the full lifecycle of a Jira ticket from "In Progress" to "Code Review" including branch management.
- **Best Practice**: Link every code change to a specific ticket via deterministic branch naming and commit messages.

## Technical Architecture
- **Language**: Python 3.9+ (Strict Typing)
- **Concurrency**: Asyncio for non-blocking subprocesses and API calls.
- **Testing**: Pytest for unit/integration tests; Shell-based verification scripts for project-level sanity.
- **Telemetry**: OpenTelemetry-compatible metrics exported to Prometheus.
- **Containerization**: Docker & Docker Compose for monitoring stack and agent execution.
